

====================================
UPLOAD

git push -u origin master
=================================================
DOWNLOAD
после git init добавляем связывающую ссылку на удалённый репо
git remote add origin https://github.com/YOUREPONAME/MyFirst.git

И для первого скачивания удалённого репо на свой компьютер, используем
git clone https://github.com/........

Дальнейшие обновления проекта из удалённого репо на локальный компьютер производятся так:
git pull origin master  (для ветки master)
git pull origin   (все ветки)


========================================================

git init
git add .
git commit -m "need to refactor"
git commit --amend -m "Add an author/email comment"   Внести изменения в тот же коммит, когда забыл какую то мелочь

gitlog   (PS Это вывод по ранее сконфигурированному Алиасу. Для вывода ограниченного кол-ва веток:  gitlog -5)

Обычно, без алиасов, используют ещё такой вариант
git log --oneline --all

=======
Создаём ветку
git checkout -b имя-новой-ветки

Переключаемся на нужную ветку
git checkout master
git checkout progress

Создание тэга и переключение по нему
git tag ver1
git checkout ver1^

“git switch -”              -  возврат к HEAD ветке 
(PS  в конце команды - это минус)

Удаление Веток
git branch -D ChildBranch

git branch - Показывает ветки и активную
====
Отмена измений (откат коммитов)

1 ДЛЯ ФАЙЛОВ
а) git checkout <file> - отменяет все изменения для этого файла, перед тем, как мы проиндексировали файл, то есть выполнили
 ADD <file>. 
(например поняли, что в одном файле нам не нужны никакие изменения)

б) Если уже сделали индексацию, то порядок такой:
git reset HEAD <file>
reset сбрасывает буферную зону к HEAD. Это очищает буферную зону от изменений, которые мы только что проиндексировали.
затем 
git checkout <file>
а checkout удаляет нежелательные изменения в рабочем каталоге.

…...

git revert <insert bad commit hash here>
Создаётся коммит, который содержит в себе - отменения указанного коммита

В локальном репозитории можно сколько угодно пользоваться РЕВЕРТами, но прежде чем делать PUSH в общий репозиторий - нужно привести ветки в порядок.
Никто не захочет разбирать в репозитории  огромным количеством ревертом.
Реверт полезен тогда, когда например попросили временно убрать какой то функционал из проекта.

git revert создает новую фиксацию с откатными изменениями. 
git reset стирает вашу историю git вместо создания нового коммита.

Удаляем текущий активный коммит и переходим на коммит ниже уровнем
git reset HEAD~1

Или можно удалить несколько коммитов подряд, количество указывается как раз после HEAD~,  то есть например удаляем 3 коммита
git reset HEAD~3

Можно сделать ресет до какой то версии
git reset --hard v1

Или до какого то ХЭШ номера
git reset --hard 39aef23

командой git hist --all
Мы их всё равно увидим удалённые коммиты, так как они ещё существуют в ветке.
Но как бы в корзине.
Окончательно и безвозвратно удаляться они лишь тогда, когда будет запущен сборщик мусора.

Но нельзя удалить конкретный коммит из серёдки списка коммитов.


=================================================
Слияние веток

Находясь в ветке MASTER пишем команду слияния
git merge feature

Далее нам необходимо разрешить все конфликты. 
Открыть конфликтные файлы и удалив лишнее, оставить нужное.


Чтобы все конфликты в файле разрешились в пользу кода в ветке MASTER
git checkout --ours index.html  

Чтобы все конфликты разрешились в пользу кода в ветке FEATURE
git checkout --theirs index.html 

git checkout --merge  - вернёт файлы в состояние конфликта (может до вас дошло, что часть конфликтов надо оставить в пользу одной ветки, а часть в пользу другой, и придётся вручную всё это проделывать)



=================================================

Если в репозиторий попали какие то ненужные файлы, которые вы забыли в gitignore
Даже если вы потом укажите их в гитигноре, они всё равно будут коммитится, потому что они уже есть в истории
Чтобы избавится от них, делаем так:

Удаление из кэша GIT не нужных файлов

git rm --cached allure-results/ -r

После этого будет правильно обрабатываться gitignore

=================================================

GIT REVERT <hash>

создаёт новый коммит который удаляет изменения, указанные в коммите <hash>
- можно указать абсолютно любой коммит из истории
  (однако, если этот коммит глубоко, может возникнуть конфликт, так как вероятнее всего, там уже что то менялось)
- можно указать последовательный диапазон коммитов, для реверта
   GIT REVERT <hash>-<hash>
   тогда создадутся ровно столько новых коммитов, сколько будет ревертировано.
=================================================